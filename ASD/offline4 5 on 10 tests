from zad4testy import runtests

def vol(building):
    return building[0]*(building[2]-building[1])

def fraction(building):
    return vol(building)/building[3]


def is_collision(B1,B2):
    return (B1[1] <= B2[1] and B1[2] >=  B2[1]) or  (B1[1] >= B2[1] and B2[2] >=  B1[1])


def if_collides_with_group(T,building,group):
    for i in range(3,len(group)):
        if is_collision(building,T[group[i]]):
            return True
    return False

def if_price_collides(p,building,group):
    return building[3] + group[1] >= p

def with_collision(building,group,T):
    newGroup = [0,0,0]
    for i in range(3,len(group)):
        if is_collision(building,T[group[i]]):
            pass
        else:
            newGroup[0] += vol(T[group[i]])
            newGroup[1] += T[group[i]][3]
            newGroup[2] += fraction(T[group[i]])
            newGroup.append(group[i])
    #print(newGroup,"frup")
    return newGroup

def look_for_collided(building,F,j,p,T):

    max_val = 0
    max_group = None
    for i in range(len(F)):
        newGroup = with_collision(building,F[i],T)
        #print(max_val,newGroup[0]+vol(building),newGroup[1]+building[3],p)
        if newGroup[2]+fraction(building) > max_val and newGroup[1]+building[3] < p:
            max_val = newGroup[2] + fraction(building)
            max_group[0] = newGroup[0] + vol(building)
            max_group[1] = newGroup[1] + building[3]
            max_group[2] = newGroup[2] + fraction(building)
    if max_group != None:
        max_group.append(j)
    #print(max_group)
    return max_group


def select_buildings(T,p):
    result = []
    n = len(T)
    F = [[0,0,0] for _ in range(n)]#pierwszy element w kazdej liscie w F jest aktualna iloscia studentow, drugi to aktualna cena
    #nastepne elementy to numerowane od 0 budynki z tablicy T ktore znajduja sie w F(i)
    #w 3 elemencie atrakcyjnosc zbudowania
    for i,build in enumerate(T):
        if build[3] < p:
            F[i][0] = vol(build)
            F[i][1] = build[3]
            F[i][2] = fraction(build)
            F[i].append(i)
        lfmax = None
        max_V = 0
        for  j in range(i-1,-1,-1):
            if (not(if_price_collides(p,build,F[j]))) and (not(if_collides_with_group(T,build,F[j]))) \
                    and (lfmax == None or max_V < F[j][2]):
                lfmax = j
                max_V = F[j][2]
        if lfmax != None:
            F[i][0] += F[lfmax][0]
            F[i][1] += F[lfmax][1]
            F[i][2] += F[lfmax][2]

            for k in range(3,len(F[lfmax])):
                F[i].append(F[lfmax][k])


        max_collided = look_for_collided(build,F,i,p,T)

        if max_collided != None and max_collided[0] > F[i][0]:
            F[i] = max_collided
                #break

        #co dodane mialo byc to dodano
        #teraz sprawdzam czy poprzedni nie jest wiekszy czasem
        #zmiana = 0
        # for j in range(i-1,-1,-1):
        #     if F[j][0] > F[i][0]:
        #         F[i] = F[j]
        #         print("zmiana")
        # print("koniec")
    max_Vol = F[0][0]
    maxID = 0

    for i in range(len(F)):
        if max_Vol <F[i][0]:
            maxID = i
            max_Vol = F[i][0]

    result = F[maxID][3:]
    return result

runtests( select_buildings )
